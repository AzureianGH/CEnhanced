module PullShape;

bring Std;
bring Std.File as File;
bring Std.Net;

extend from "C" i32 mkdir(char*, i32);
extend from "C" i32 access(char*, i32);
extend from "C" void* popen(char*, char*);
extend from "C" i32 pclose(void*);
extend from "C" i32 fread(void*, i32, i32, void*);
extend from "C" i32 sprintf(char*, char*, ...);
extend from "C" i32 snprintf(char*, i32, char*, ...);

constant string SCHEME = "https:";
constant string URL = "//ecams.geico.com/resources/js/sga_0924.js";

hide fun digit(i32 value, char* buffer) -> void
{
    if (value < 10)
    {
        buffer[0] = '0';
        buffer[1] = ('0' as i32 + value) as char;
    }
    else
    {
        buffer[0] = ('0' as i32 + (value / 10)) as char;
        buffer[1] = ('0' as i32 + (value % 10)) as char;
    }
    buffer[2] = 0;
    ret;
}

hide fun directory_exists(char* path) -> bool
{
    ret access(path, 0) == 0;
}

hide fun parse_host_and_path(char* url, char** out_host, char** out_path) -> bool
{
    if (url == null || out_host == null || out_path == null)
        ret false;

    i32 total_len = Std.String.strlen(url);
    if (total_len < 2)
        ret false;
    if (url[0] != '/' || url[1] != '/')
        ret false;

    char* cursor = url + 2;
    i32 host_len = 0;

    while ((2 + host_len) < total_len && cursor[host_len] != 0 && cursor[host_len] != '/')
    {
        host_len = host_len + 1;
    }

    if (host_len == 0)
        ret false;

    char* host = Std.Memory.alloc(host_len + 1) as char*;
    if (host == null)
        ret false;
    Std.Memory.memcpy(host as void*, cursor as void*, host_len);
    host[host_len] = 0;

    i32 path_len = total_len - (2 + host_len);
    if (path_len <= 0)
    {
        char* path = Std.Memory.alloc(2) as char*;
        if (path == null)
        {
            Std.Memory.dealloc(host as void*);
            ret false;
        }
        path[0] = '/';
        path[1] = 0;
        *out_host = host;
        *out_path = path;
        ret true;
    }

    char* path = Std.Memory.alloc(path_len + 1) as char*;
    if (path == null)
    {
        Std.Memory.dealloc(host as void*);
        ret false;
    }
    Std.Memory.memcpy(path as void*, (cursor + host_len) as void*, path_len);
    path[path_len] = 0;

    *out_host = host;
    *out_path = path;
    ret true;
}

hide fun get_directory_name(i32 serial) -> string
{
    i32 year = 2025;
    i32 month = 12;
    i32 day = 26;
    
    char* name = Std.Memory.alloc(64) as char*;
    
    char[3] year_str = {};
    char[3] month_str = {};
    char[3] day_str = {};
    char[3] serial_str = {};
    
    digit(year % 100, year_str as char*);
    digit(month, month_str as char*);
    digit(day, day_str as char*);
    digit(serial, serial_str as char*);
    
    sprintf(name, "20%s%s%s-%s", 
            year_str as char*, 
            month_str as char*, 
            day_str as char*, 
            serial_str as char*);
    
    if (!directory_exists(name))
    {
        mkdir(name, 0o755);
        ret name;
    }
    
    Std.Memory.dealloc(name as void*);
    ret get_directory_name(serial + 1);
}

hide fun extract_payload_url(char* injector) -> string
{
    char* search = injector;
    i32 url_len = Std.String.strlen(URL);
    
    while (*search != 0)
    {
        if (*search == '"' || *search == '\'')
        {
            char* potential = search + 1;
            bool matches = true;
            
            for (i32 i = 0; i < url_len && matches; i = i + 1)
            {
                if (potential[i] != URL[i])
                {
                    matches = false;
                }
            }
            
            if (matches)
            {
                i32 end = 0;
                char quote = *search;
                potential = search + 1;
                
                while (potential[end] != 0 && potential[end] != quote)
                {
                    end = end + 1;
                }
                
                char* result = Std.Memory.alloc(end + 1) as char*;
                Std.Memory.memcpy(result as void*, potential as void*, end);
                result[end] = 0;
                
                ret result;
            }
        }
        
        search = search + 1;
    }
    
    ret null;
}

hide fun http_fetch_socket(char* host, char* path) -> string
{
    if (host == null || path == null)
        ret null;

    i32 sock = Std.Net.tcp_connect(host, 80);
    if (sock < 0)
        ret null;

    char* request = Std.Memory.alloc(512) as char*;
    i32 req_len = snprintf(request, 512,
        "GET %s HTTP/1.0\r\nHost: %s\r\nUser-Agent: pullShape/1.0\r\nConnection: close\r\n\r\n",
        path, host);

    if (req_len <= 0 || Std.Net.tcp_send_all(sock, request as void*, req_len) < req_len)
    {
        Std.Memory.dealloc(request as void*);
        Std.Net.tcp_close(sock);
        Std.Net.cleanup();
        ret null;
    }

    Std.Memory.dealloc(request as void*);

    i32 cap = 1024 * 1024;
    char* response = Std.Memory.alloc(cap) as char*;
    i32 total = 0;

    while (true)
    {
        if (total >= cap - 4096)
            break;

        i32 rc = Std.Net.tcp_recv(sock, (response + total) as void*, cap - total - 1);
        if (rc <= 0)
            break;
        total = total + rc;
    }

    response[total] = 0;
    Std.Net.tcp_close(sock);
    Std.Net.cleanup();

    i32 idx = 0;
    while (idx + 3 < total)
    {
        if (response[idx] == '\r' && response[idx + 1] == '\n' &&
            response[idx + 2] == '\r' && response[idx + 3] == '\n')
        {
            i32 body_len = total - (idx + 4);
            char* body = Std.Memory.alloc(body_len + 1) as char*;
            Std.Memory.memcpy(body as void*, (response + idx + 4) as void*, body_len);
            body[body_len] = 0;
            Std.Memory.dealloc(response as void*);
            ret body;
        }
        idx = idx + 1;
    }

    Std.Memory.dealloc(response as void*);
    ret null;
}

hide fun curl_fetch(char* url) -> string
{
    char* command = Std.Memory.alloc(512) as char*;
    snprintf(command, 512, "curl -s '%s%s'", SCHEME, url);
    void* pipe = popen(command, "r");
    Std.Memory.dealloc(command as void*);

    if (pipe == null)
    {
        Std.IO.print("Failed to execute curl command\n");
        ret null;
    }

    char* buffer = Std.Memory.alloc(1024 * 1024) as char*;
    i32 total_read = 0;
    i32 bytes_read = 0;
    char[4096] chunk = {};

    while ((bytes_read = fread(chunk as void*, 1, 4096, pipe)) > 0)
    {
        Std.Memory.memcpy((buffer + total_read) as void*, chunk as void*, bytes_read);
        total_read = total_read + bytes_read;
    }

    buffer[total_read] = 0;
    pclose(pipe);

    ret buffer;
}

hide fun get_content(char* url) -> string
{
    char* host = null;
    char* path = null;

    bool parsed = parse_host_and_path(url, &host, &path);
    if (!parsed)
        ret curl_fetch(url);

    string body = null;

    body = http_fetch_socket(host, path);

    if (body == null)
    {
        Std.IO.print("Socket fetch failed; falling back to curl for %s%s\n", SCHEME, url);
        body = curl_fetch(url);
    }

    Std.Memory.dealloc(host as void*);
    Std.Memory.dealloc(path as void*);
    ret body;
}

[EntryPoint]
expose fun main() -> i32
{
    Std.IO.print("Fetching injector from %s%s...\n", SCHEME, URL);
    
    char* injector = get_content(URL as char*);
    
    if (injector == null)
    {
        Std.IO.print("Failed to fetch injector\n");
        ret 1;
    }
    
    Std.IO.print("Extracting payload URL...\n");
    char* payload_url = extract_payload_url(injector);
    
    if (payload_url == null)
    {
        Std.IO.print("Failed to extract payload URL\n");
        Std.Memory.dealloc(injector as void*);
        ret 1;
    }
    
    Std.IO.print("Fetching payload from %s...\n", payload_url);
    char* payload = get_content(payload_url);
    
    if (payload == null)
    {
        Std.IO.print("Failed to fetch payload\n");
        Std.Memory.dealloc(injector as void*);
        Std.Memory.dealloc(payload_url as void*);
        ret 1;
    }
    
    char* dir_name = get_directory_name(1);
    Std.IO.print("Saving files to directory: %s\n", dir_name);
    
    char* injector_path = Std.Memory.alloc(128) as char*;
    sprintf(injector_path, "%s/injector.js", dir_name);
    
    i32 injector_len = Std.String.strlen(injector);
    File.write_all(injector_path, injector as void*, injector_len);
    Std.IO.print("Saved injector.js (%d bytes)\n", injector_len);
    
    char* payload_path = Std.Memory.alloc(128) as char*;
    sprintf(payload_path, "%s/payload.js", dir_name);
    
    i32 payload_len = Std.String.strlen(payload);
    File.write_all(payload_path, payload as void*, payload_len);
    Std.IO.print("Saved payload.js (%d bytes)\n", payload_len);
    
    Std.Memory.dealloc(injector as void*);
    Std.Memory.dealloc(payload as void*);
    Std.Memory.dealloc(payload_url as void*);
    Std.Memory.dealloc(dir_name as void*);
    Std.Memory.dealloc(injector_path as void*);
    Std.Memory.dealloc(payload_path as void*);
    
    Std.IO.print("Done!\n");
    ret 0;
}
