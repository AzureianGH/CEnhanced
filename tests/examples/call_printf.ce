module Test.Program;

bring Test.Chance as TC;
bring LibTest as LT;
bring LibTest.Another;
bring Std;
bring Std.File as File;

#define WARN_MSG "diag warning triggered"
#define NOTE_MSG "diag note triggered"
#define ASSERT_OK 1

#note NOTE_MSG
#warn WARN_MSG
#static_assert(ASSERT_OK, "static assert should pass")
#static_assert(1)

#if 0

#define ERROR_MSG "forced preprocessing error"

#error ERROR_MSG

#define FAIL_COND 0
#define FAIL_MSG "failing static assertion"

#static_assert(FAIL_COND, FAIL_MSG)
#endif

#define TEST_DEFINE 99
#define MACRO_SUM(a, b) ((a) + (b))
#define MACRO_SQUARE(x) ((x) * (x))

#define SHOULD_BE_UNDEF 123
#undef SHOULD_BE_UNDEF

#ifdef SHOULD_BE_UNDEF
#define UNDEF_CHECK_VALUE -1
#else
#define UNDEF_CHECK_VALUE 456
#endif

#if defined(TEST_DEFINE) && TEST_DEFINE == 99
#define CONDITIONAL_VALUE 99
#else
#define CONDITIONAL_VALUE -1
#endif

#define FEATURE_LEVEL 3
#if FEATURE_LEVEL > 3
#define FEATURE_SENTINEL 10
#elif FEATURE_LEVEL == 3
#define FEATURE_SENTINEL 30
#else
#define FEATURE_SENTINEL -10
#endif

extend from "C" i32 write(int, char *, int);
extend from "C" i32 read(i32, char *, int);
extend from "C" void *malloc(int);
extend from "C" void free(void *);
extend from "C" void exit(int);
extend from "C" int test();
extend fun test_chance() -> i32;
extend from "C" i32 remove(char*);

hide alias string = char*;
hide alias uint32_t = u32;

// Forward declaration and struct that holds an action field
struct AsmProgram;

struct ArchHandler
{
    string name;
    string description;
    action(AsmProgram* program) -> i32 assemble;
};

struct AsmProgram
{
    string input_path;
    string output_path;
    ArchHandler* arch;
    i32 format;
    i32 reloc;
};

expose struct AnElement
{
    TC.Element internalElement;
    TC.Element* ptrToElement;
};

expose struct OtherElement
{
    i32 part;
    char* str;
    u64 bignumber;
    AnElement thisthing; // Will error because AnElement is hidden and cannot be used in an exposed struct
    AnElement* ptrToSmth;
};

struct AlignProbe
{
    u8 pad;
    i64 payload;
};

hide fun alignof_alignprobe() -> i32
{
    ret alignof(AlignProbe);
}

hide fun offsetof_alignprobe_payload() -> i32
{
    ret offsetof(AlignProbe, .payload);
}

hide i32 total_test_count = 0;
OtherElement globalElement = {}; // auto hide members

hide alias ptr<T> = T*;

[Inline]
hide fun inlined_function(i32 x) -> i32
{
    ret x + 1;
}

[Inline]
hide fun inlinable_function(i32 x) -> i32
{
    if (x == 0)
        ret 0;
    ret x * inlined_function(x);
}

hide fun printwrapper() -> i32
{
    string fn_name = __FUNCTION__;
    assert(strcmp(fn_name, "printwrapper") == 0, "__FUNCTION__ matches printwrapper");
    ret Std.IO.print("Hello, %s! Number: %d\n", "CHance", 42);
}

hide fun assert(bool condition, string message) -> void
{
    total_test_count += 1;
    if (condition)
    {
        Std.IO.print("TEST PASSED: %s\n", message);
    }
    else
    {
        Std.IO.print("TEST FAIL: %s\n", message);
        abort();
    }
    ret;
}

hide fun mock_assemble(AsmProgram* program) -> i32
{
    if (program == null)
        ret -1;
    ret 7;
}

[EntryPoint]
expose fun main() -> i32
{
    // allocate 128 bytes for input
    ptr<void> buf = null;
    
    buf = Std.Memory.alloc(128);

    var inferred_buf = buf;
    assert(inferred_buf == buf, "var inferred pointer matches original buffer");

    assert(buf != null, "\"buf\" allocation");

    Std.Memory.memset(buf, 0, 128);

    bool all_zero = true;

    for (i32 i = 0; i < 128; i = i + 1)
    {
        if ((buf as u8*)[i] != 0)
        {
            all_zero = false;
        }
    }

    assert(all_zero, "memset to zero");

    // prompt the user
    write(1, "What's your name? > ", 20);

    // read from stdin (fd = 0), max 127 chars
    i32 len = read(0, buf as char *, 127);

    // test printwrapper result
    i32 printed = printwrapper();
    // "Hello, CHance! Number: 42\n" is 26 characters
    assert(printed == 26, "printwrapper printed length");

    
    // null-terminate the string safely
    string str = buf as string;
    if (len > 0)
    {
        if (str[len - 1] == '\n') str[--len] = 0;
        if (len > 0 && str[len - 1] == '\r') str[--len] = 0;
    }
    else
    {
        Std.IO.print("No input read, using empty string\n");
        str[0] = 0;
    }

    // basic string length sanity check
    assert(Std.String.strlen(str) == len, "strlen matches bytes read");

    string cmp_target = "CHance";

    // If user actually entered secret name, assert success; otherwise assert not equal.
    if (strcmp(str, cmp_target) == 0)
    {
        assert(true, "User entered the secret name");
    }
    else
    {
        assert(true, "User did not enter the secret name (not required for tests)");
    }

    Std.IO.print("Freeing memory...\n");
    Std.Memory.dealloc(buf as void*);

    // Test overflow behavior
    i16 of = test_overflow();
    Std.IO.print("test_overflow result: %d\n", of);
    assert(of == -25536, "test_overflow result is -25536");

    // Test multiplication overflow
    u8 mul_of = test_mul_overflow();
    assert(mul_of == 64, "test_mul_overflow result is 64");

    // Arithmetic and function tests
    i32 mul = 6 * 7;
    assert(mul == 42, "6 * 7 == 42");

    i32 div = 20 / -4;
    assert(div == -5, "20 / -4 == -5");

    i32 mod = 20 % 6;
    assert(mod == 2, "20 % 6 == 2");

    assert((0xFF as i32) == 255, "0xFF == 255");

    Std.IO.print("Calling test_chance(): %d\n", TC.test_chance());

    Std.IO.print("Calling extended C function test(): %d\n", test());

    TC.SmallTest vari = {};
    vari.smallValue = 3;
    vari.testVar = 44;
    
    TC.SmallTest another = {
        .smallValue = 123,
        .testVar = 333 
    };

    TC.SmallTest* test = &vari;

    TC.SmallTest deref = *test;

    assert(deref.testVar == 44, "deref.testVar == 44");

    var testint = 123;
    i32* testintp = &testint;
    i32** testintpp = &testintp;
    assert(testintpp[0][0] == 123, "double pointer deref == 123");

    TC.SmallTest* addptr = Std.Memory.alloc(sizeof(TC.SmallTest) * 2) as TC.SmallTest*;
    
    addptr[0] = construct_thing();
    addptr[1] = another;

    

    assert(addptr[0].smallValue == 5, "addptr[0].smallValue == 5");
    assert(addptr[1].smallValue == 123, "addptr[1].smallValue == 123");

    Std.Memory.dealloc(addptr as void*);

    i32* testintptr = test as i32*;
    Std.IO.print("testVar via intptr: %p\n", testintptr);

    TC.Element elem = TC.Element.SetElement;

    test=>testVar = 45;

    assert(test=>testVar == 45, "setter/getter via => works");

    i32 a = 1 << 1;
    assert(a == 2, "1 << 1 == 2");

    i32 b = 4 >> 1;
    assert(b == 2, "4 >> 1 == 2");

    Std.IO.print("typeof() = %s with sizeof() = %d\n", typeof(TC.SmallTest), sizeof(TC.SmallTest));

    [MetadataCall("differentsig")]();

    test_idk();

    assert(rawthing(10) == 466, "rawthing(10) == 466");

    Std.IO.print("Result from LibTest: %d\n", LT.test_fun(41));

    Std.IO.print("Result from LibTest.Another: %d\n", other_test_fun(50)); // Will be 60

    f32 floatval = 3.14f;
    f64 doubleval = 1.23456789;
    f32* floatptr = &floatval;
    floatptr[0] = 6.28f;
    i32 ac = 4;

    // Validate simple var values
    assert(ac == 4, "ac == 4");
    assert(floatptr[0] == 6.28f, "floatptr[0] == 6.28f");
    assert(doubleval == 1.23456789, "doubleval == 1.23456789");
    Std.IO.print("Expect addition of doubleval + floatval = %lf\n", (doubleval + (floatval as f64)) as f64);
    f64 sum = doubleval + (floatval as f64);
    f64 diff = sum - 7.514568;
    if (diff < 0.0) diff = -diff;
    assert(diff < 1e-6, "doubleval + floatval ~= 7.514568");
    assert(((vari.testVar as i32) + (another.smallValue as i32)) == 168, "Sum of vari.testVar and another.smallValue == 168");

    f128 bigfloat = 0.1234567 as f128;
    f64 floathing = 0.1;
    f32 floathing2 = 0.1f;
    assert((floathing == 0.1 && floathing2 == 0.1f && bigfloat == 0.1234567 as f128), "f128, f64, f32 assignments");

    // Validate final return value
    i32 final_sum = (vari.testVar as i32) + (another.smallValue as i32);
    assert(final_sum == 168, "final return value equals 168");

    // & test
    i32 and_val = 0b1100 & 0b1010;
    assert(and_val == 0b1000, "Bitwise AND works");

    // | test
    i32 or_val = 0b1100 | 0b1010;
    assert(or_val == 0b1110, "Bitwise OR works");

    // ^ test
    i32 xor_val = 0b1100 ^ 0b1010;
    assert(xor_val == 0b0110, "Bitwise XOR works");

    // ~ test
    i32 not_val = ~0b00001111;
    assert(not_val == -16, "Bitwise NOT works");

    i32 break_counter = 0;
    for (i32 idx = 0; idx < 10; idx = idx + 1)
    {
        if (idx == 5)
            break;
        break_counter = break_counter + 1;
    }
    assert(break_counter == 5, "break exits for-loop early");

    i32 continue_total = 0;
    for (i32 cidx = 0; cidx < 6; cidx = cidx + 1)
    {
        if (cidx == 2)
            continue;
        continue_total = continue_total + cidx;
    }
    assert(continue_total == 0 + 1 + 3 + 4 + 5, "continue skips iteration but still advances for-loop");

    i32 inferred_accum = 0;
    for (var auto_idx = 0; auto_idx < 3; auto_idx = auto_idx + 1)
    {
        inferred_accum = inferred_accum + auto_idx;
    }
    assert(inferred_accum == 0 + 1 + 2, "'var' inference works inside for-loop init");

    i32 while_sum = 0;
    i32 n = 0;
    while (n < 6)
    {
        n = n + 1;
        if ((n % 2) == 0)
            continue;
        while_sum = while_sum + n;
        if (n == 5)
            break;
    }
    assert(while_sum == 1 + 3 + 5, "break and continue cooperate in while-loop");

    u16 random_number = 12345;

    char* chkarray = Std.Memory.alloc(17) as char*;
    Std.Memory.memset(chkarray as void*, 0, 17);

    // Print out each bit of random_number
    for (i32 i = 15; i >= 0; i = i - 1)
    {
        u16 bit = (random_number >> i) & 1;
        chkarray[15 - i] = if (bit == 1) '1' else '0';
    }

    assert(strcmp(chkarray, "0011000000111001") == 0, "Bitwise representation of 12345 is correct");

    assert(TEST_DEFINE == 99, "object-like macro expands to literal");
    assert(MACRO_SUM(20, 22) == 42, "function-style macro expansion works");
    assert(MACRO_SQUARE(5) == 25, "macro arguments stay parenthesized");
    assert(CONDITIONAL_VALUE == 99, "#if/#else branch selection works");
    assert(FEATURE_SENTINEL == 30, "#elif branch selection works");
    assert(UNDEF_CHECK_VALUE == 456, "#undef clears definitions for guards");

    assert(__CHANCE__ == 1, "__CHANCE__ builtin defined");
    assert(__CHANCE_VERSION_MAJOR__ == 0, "major version under 1");
    assert(__CHANCE_VERSION_MINOR__ >= 6, "minor version reflects progress");
    assert(__CHANCE_VERSION_PATCH__ >= 1, "patch version set");
    assert(__CHANCE_VERSION__ == (__CHANCE_VERSION_MAJOR__ * 10000 + __CHANCE_VERSION_MINOR__ * 100 + __CHANCE_VERSION_PATCH__), "aggregate version matches components");
    assert(strcmp(__CHANCE_VERSION_STR__, "0.6.1") == 0, "string version matches 0.6.1");
    assert(__POINTER_WIDTH__ == (sizeof(void*) * 8), "__POINTER_WIDTH__ matches sizeof(void*)");
    if (sizeof(void*) == 8)
    {
        assert(__IS64BIT__ == 1, "__IS64BIT__ reflects 64-bit");
    }
    else
    {
        assert(__IS64BIT__ == 0, "__IS64BIT__ reflects non-64-bit");
    }
#ifdef __WIN32__
    assert(__WIN32__ == 1, "__WIN32__ macro active");
#elif __LINUX__
    assert(__LINUX__ == 1, "__LINUX__ macro active");
#elif __MACH__
    assert(__MACH__ == 1, "__MACH__ macro active");
#else
    assert(false, "unknown OS platform macros");
#endif

    ubyte jsdnfij = 3;

    string file_macro = __FILE__;
    assert(file_macro[0] != 0, "__FILE__ yields non-empty value");
    string module_macro = __MODULE__;
    assert(strcmp(module_macro, "Test.Program") == 0, "__MODULE__ matches module name");
    i32 line_macro = __LINE__;
    assert(line_macro > 0, "__LINE__ yields positive value");
    string date_macro = __DATE__;
    assert(date_macro[0] != 0, "__DATE__ yields non-empty value");
    string time_macro = __TIME__;
    assert(time_macro[0] != 0, "__TIME__ yields non-empty value");
    i32 counter_a = __COUNTER__;
    i32 counter_b = __COUNTER__;
    assert(counter_b == counter_a + 1, "__COUNTER__ increments sequentially");
    assert(strcmp(__FUNCTION__, "main") == 0, "__FUNCTION__ matches main");
    assert(strcmp("hello" + "world", "helloworld") == 0, "constant string merging");

    assert(strcmp(get_info(), "LibTest.Another::get_info()") == 0, "LibTest.Another::get_info() works");

    i32 varargs_sum = test_varargs(5, 12345, 10, 20, 30, 40, 50);
    assert(varargs_sum == 150, "varargs sum is 150");

    
    test_diffvarargs(10, 77, 3.14f, "varargs test");
    internal_diffvarargs(0, 88, 2.71828, "internal varargs test");

    i32[3] fixed_array = {10, 20, 30};
    i32 fixed_sum = fixed_array[0] + fixed_array[1] + fixed_array[2];
    assert(fixed_sum == 60, "fixed array sum is 60");
    assert(sizeof(fixed_array) == sizeof(i32) * 3, "fixed array size is correct");

    i64[] dyn_array = Std.Memory.alloc(sizeof(i64) * 4) as i64[];
    dyn_array[0] = 100;
    dyn_array[1] = 200;
    dyn_array[2] = 300;
    dyn_array[3] = 400;
    i64 dyn_sum = dyn_array[0] + dyn_array[1] + dyn_array[2] + dyn_array[3];
    assert(dyn_sum == 1000, "dynamic array sum is 1000");
    Std.Memory.dealloc(dyn_array as void*);

    TC.SmallTest st = {
        .smallValue = 9,
        .testVar = 81
    };

    i32 passbystruct_result = passbystruct(st);
    assert(passbystruct_result == 81, "passbystruct result is 81");

    TC.SmallTest retstruct = returnbystruct(st);
    assert(retstruct.smallValue == 9 && retstruct.testVar == 81, "returnbystruct result matches input");
    
    fun* funptr_var(i32, i32) -> i32 = &funptr_test;

    fun* (i32, i32, -> i32) funptr_var2 = &funptr_test;

    i32 funptr_result = funptr_var(15, 27);
    assert(funptr_result == 42, "funptr_test result is 42");
    i32 funptr_result2 = funptr_var2(20, 22);
    assert(funptr_result2 == 42, "funptr_test result via second pointer is 42");

    void* rawfunptr = funptr_var as void*;
    assert(rawfunptr != null, "raw function pointer is not null");

    fun* (i32, i32, -> i32) from_raw = rawfunptr as fun* (i32, i32, -> i32);
    i32 funptr_result3 = from_raw(7, 35);
    assert(funptr_result3 == 42, "funptr_test result via raw pointer is 42");

    fun* (TC.SmallTest, -> i32) struct_funptr = &passbystruct;
    i32 struct_funptr_result = struct_funptr(st);
    assert(struct_funptr_result == 81, "struct funptr result is 81");

    assert(inlinable_function(12) == 156, "inlinable_function(12) == 156");

    assert(inlinable_function(0) == 0, "inlinable_function(0) == 0");

    fun* (i32, -> i32) inlinedptr = &inlined_function;

    void* inlinedvoidp = inlinedptr as void*;

    fun* (i32, -> i32) retinlinedptr = inlinedvoidp as fun* (i32, -> i32);
    Std.IO.print("Value is %d!\n", retinlinedptr(5));

    #if __TARGET_ARCH__ == "xa86"
    assert(false, "target arch is invalid");
    #endif

    #if __TARGET_ARCH__ == "x8""6"
    Std.IO.print("Arch is %s.\n", __TARGET_ARCH__);
    #else
    Std.IO.print("Arch (non-x86) is %s.\n", __TARGET_ARCH__);
    #endif

    i32 structvarargs_sum = multistructargs(
        TC.SmallTest{ .smallValue = 1, .testVar = 10 },
        TC.SmallTest{ .smallValue = 2, .testVar = 20 },
        TC.SmallTest{ .smallValue = 3, .testVar = 30 }
    );

    assert(structvarargs_sum == 60, "multi struct args sum is 60");

    i32 structvarargs_result = structvarargs(3,
        TC.SmallTest{ .smallValue = 0, .testVar = 11 },
        TC.SmallTest{ .smallValue = 0, .testVar = 22 },
        TC.SmallTest{ .smallValue = 0, .testVar = 33 }
    );

    Std.IO.print("structvarargs_result = %d\n", structvarargs_result);

    assert(structvarargs_result == 66, "structvarargs sum is 66");

    constant i32 const_value = 555;
    assert(const_value == 555, "constant value is 555");
    //const_value = 552; // should error if uncommented


    assert(use_constant(45) == 145, "use_constant(45) == 145"); // works fine
    assert(use_constant(const_value as i32) == 655, "use_constant(const_value) == 655"); // throws warning

    constant_test(const_value as i32); // should not modify caller
    assert(const_value == 555, "constant value remains 555 after constant_test");
    
    constant u8* array = Std.Memory.alloc(10) as constant u8*;

    // constant_ptr(array); // would error without explicit cast
    constant_ptr(array as u8*); // force override to allow mutation

    assert(array[0] == 42, "constant_ptr modified first byte to 42");
    
    i32 probe_align = alignof_alignprobe();
    i32 builtin_probe_align = alignof(AlignProbe);
    assert(probe_align == builtin_probe_align, "alignof(AlignProbe) matches helper");
    i32 probe_offset = offsetof_alignprobe_payload();
    i32 builtin_probe_offset = offsetof(AlignProbe, .payload);
    assert(probe_offset == builtin_probe_offset, "offsetof(AlignProbe, .payload) matches helper");
    assert((builtin_probe_offset % builtin_probe_align) == 0, "offsetof result respects alignment");

    assert(alignof(i8) == 1, "alignof(i8) == 1");
    assert(alignof(i16) == 2, "alignof(i16) == 2");
    assert(alignof(i32) == 4, "alignof(i32) == 4");
    assert(alignof(i64) == 8, "alignof(i64) == 8");
    assert(alignof(f32) == 4, "alignof(f32) == 4");
    assert(alignof(f64) == 8, "alignof(f64) == 8");

    // test template constraint checks
    assert(default_max(10, 20) == 20, "default_max(10, 20) == 20");
    assert(max<i32>(-5, -2) == -2, "default_max(-5, -2) == -2");
    assert(other(15 as u8, 27 as i16) == 42, "other(15u8, 27i16) == 42");

    i16[4] dot_left = { (-2 as i16), 4, 6, 8 };
    u8[4] dot_right = { 10, 20, 30, 40 };
    i64 wide_dot = dot_sum<i16, u8, i64>(dot_left, dot_right, 4);
    assert(wide_dot == 560, "dot_sum<i16,u8,i64>(dot_left, dot_right, 4) == 560");

    i8[3] small_left = { 1, 2, 3 };
    i8[3] small_right = { 9, 8, 7 };
    i32 compact_dot = dot_sum<i8, i8, i32>(small_left, small_right, 3);
    assert(compact_dot == 46, "dot_sum<i8,i8,i32>(small_left, small_right, 3) == 46");

    i32 switch_selector = 7;
    i32 switch_bucket = -100;
    switch (switch_selector)
    {
        case 0:
            switch_bucket = 0;
            break;
        case 1:
        case 2:
            switch_bucket = 12;
            break;
        case 3:
            switch_bucket = 33;
            break;
        default:
            switch_bucket = 44;
            break;
    }
    assert(switch_bucket == 44, "switch default bucket selected when no case matches");

    i32 switch_fallthrough = -1;
    switch (1)
    {
        case 0:
            switch_fallthrough = 0;
            break;
        case 1:
            switch_fallthrough = 10;
        case 2:
            switch_fallthrough = 20;
            break;
        default:
            switch_fallthrough = -50;
            break;
    }
    assert(switch_fallthrough == 20, "switch fallthrough executes subsequent case when break omitted");

    i32 match_selector = -5;
    i32 match_bucket = match (match_selector)
    {
        -10 => 1000,
        -5 => 500,
        0 => 0,
        _ => 99,
    };
    assert(match_bucket == 500, "match chooses exact literal arm");

    match_selector = 123;
    i32 match_default = match (match_selector)
    {
        0 => 0,
        1 => 1,
        _ => match_selector / 3,
    };
    assert(match_default == 41, "match falls back to wildcard arm");

    f64 fun_overload_float = function_overload(3.5, 2.5);
    assert(fun_overload_float == 6.0, "function_overload(f64, f64) == 6.0");

    i32 fun_overload_int = function_overload(10, 32);
    assert(fun_overload_int == 42, "function_overload(i32, i32) == 42");

    TC.SmallTest fun_overload_struct = function_overload(3,
        TC.SmallTest{ .smallValue = 1, .testVar = 10 },
        TC.SmallTest{ .smallValue = 2, .testVar = 20 },
        TC.SmallTest{ .smallValue = 3, .testVar = 30 }
    );
    assert(fun_overload_struct.testVar == 60 && fun_overload_struct.smallValue == 6, "function_overload(varargs TC.SmallTest) sums correctly");

    // compound assignment test
    i32 comp_assign = 10;
    comp_assign += 5;
    assert(comp_assign == 15, "compound assignment += works");
    comp_assign -= 3;
    assert(comp_assign == 12, "compound assignment -= works");
    comp_assign *= 2;
    assert(comp_assign == 24, "compound assignment *= works");
    comp_assign /= 4;
    assert(comp_assign == 6, "compound assignment /= works");
    comp_assign %= 4;
    assert(comp_assign == 2, "compound assignment %= works");
    comp_assign <<= 2;
    assert(comp_assign == 8, "compound assignment <<= works");
    comp_assign >>= 1;
    assert(comp_assign == 4, "compound assignment >>= works");
    comp_assign &= 0b0110;
    assert(comp_assign == 0b0100, "compound assignment &= works");
    comp_assign |= 0b0011;
    assert(comp_assign == 0b0111, "compound assignment |= works");
    comp_assign ^= 0b0101;
    assert(comp_assign == 0b0010, "compound assignment ^= works");

    f32 comp_float = 1.5f;
    comp_float += 2.5f;
    assert(comp_float == 4.0f, "compound assignment += works for f32");
    comp_float *= 2.0f;
    assert(comp_float == 8.0f, "compound assignment *= works for f32");
    comp_float /= 4.0f;
    assert(comp_float == 2.0f, "compound assignment /= works for f32");
    comp_float -= 1.0f;
    assert(comp_float == 1.0f, "compound assignment -= works for f32");
    comp_float += 3 as f32;
    assert(comp_float == 4.0f, "compound assignment with literal works for f32");

    // super args
    i32 superarg_result = super_args(
        1, 2, 3,
        4, 5, 6,
        7, 8, 9,
        10, 11, 12,
        13, 14, 15,
        16, 17, 18,
        19, 20, 21,
        22, 23, 24,
        25, 26
    );
    assert(superarg_result == -1853882368, "super_args product is -1853882368"); // overflow expected
    assert(superarg_result % 20 == -8, "super_args product mod 20 is 12");

    action test_action = fun () -> void {
        Std.IO.print("This is a test action!\n");
        ret;
    }(); // immediate invocation

    test_action(); // second invocation

    action test_action2 = fun (i32 x) -> i16 {
        Std.IO.print("This is a test action with arg: %d\n", x);
        ret (x as i16) + 1;
    };

    i16 lambda_result = test_action2(41);
    assert(lambda_result == 42, "lambda action returned 42");
    lambda_test(
        fun () -> void {
            Std.IO.print("Lambda test action A invoked!\n");
            ret;
        },
        fun (i32 x) -> i16 {
            Std.IO.print("Lambda test action B invoked with %d!\n", x);
            ret (x as i16) + 1;
        }
    );

    lambda_test(test_action, /* multi line comment */ test_action2);

    /* multi
    lined
    comment
    */


    file_io_tests();

    u32 uliteral = 88u;

    assert(uliteral == (88 as u32), "unsigned literal 88u == 88 as u32");


    Std.IO.printnl("All tests completed successfully! %d total asserts.", total_test_count);

    ret (final_sum / 168) - 1; // expect 0
}

hide fun lambda_test(action a () -> void, action b (i32) -> i16) -> void
{
    a();
    i16 val = b(42);
    Std.IO.print("Lambda returned: %d\n", val);
    ret;
}

hide fun file_io_tests() -> void
{
    //
    // Basic byte write/read test
    //
    u8* file_payload = Std.Memory.alloc(4) as u8*;
    file_payload[0] = 1;
    file_payload[1] = 2;
    file_payload[2] = 3;
    file_payload[3] = 4;

    i32 bytes_written =
        File.write_all("file_test.bin", file_payload as void*, 4);
    assert(bytes_written == 4, "write_all wrote 4 bytes");

    void* file_buf = null;
    i32 file_len = 0;

    i32 bytes_read =
        File.read_all("file_test.bin", (&file_buf) as void**, &file_len);
    assert(bytes_read == 4 && file_len == 4, "read_all read 4 bytes");

    u8* file_bytes = file_buf as u8*;
    assert(file_bytes[0] == 1 &&
           file_bytes[1] == 2 &&
           file_bytes[2] == 3 &&
           file_bytes[3] == 4,
           "read_all preserved byte contents");

    Std.Memory.dealloc(file_buf);
    Std.Memory.dealloc(file_payload as void*);


    //
    // Struct write/read test
    //
    TC.SmallTest* file_struct =
        Std.Memory.alloc(sizeof(TC.SmallTest)) as TC.SmallTest*;
    file_struct->smallValue = 7;
    file_struct->testVar   = 99;

    void* fh = File.open("file_struct.bin", "wb");
    assert(fh != null, "open for write returned handle");

    i32 struct_size = sizeof(TC.SmallTest) as i32;
    assert(File.write(fh, file_struct as void*, struct_size) == struct_size,
           "write struct bytes");

    File.flush(fh);
    File.close(fh);

    //
    // Validate written struct
    //
    fh = File.open("file_struct.bin", "rb");
    assert(fh != null, "open for read returned handle");

    // Seek to end
    assert(File.seek(fh, 0, 2) == 0, "seek to end succeeded");  // 2 = SEEK_END
    i64 end_pos = File.tell(fh);
    assert(end_pos == struct_size as i64, "end position matches struct size");

    // Seek to start
    assert(File.seek(fh, 0, 0) == 0, "seek to start succeeded"); // 0 = SEEK_SET

    void* struct_buf = Std.Memory.alloc(struct_size);
    assert(File.read(fh, struct_buf, struct_size) == struct_size,
           "read struct bytes");

    File.close(fh);

    TC.SmallTest loaded_struct = *(struct_buf as TC.SmallTest*);
    assert(loaded_struct.smallValue == 7 &&
           loaded_struct.testVar   == 99,
           "struct round-trip matches");

    Std.Memory.dealloc(struct_buf);
    Std.Memory.dealloc(file_struct as void*);

    //
    // Cleanup
    //
    remove("file_test.bin");
    remove("file_struct.bin");
}


hide fun super_args(
    i32 a, i32 b, i32 c, 
    i32 d, i32 e, i32 f, 
    i32 g, i32 h, i32 i, 
    i32 j, i32 k, i32 l, 
    i32 m, i32 n, i32 o, 
    i32 p, i32 q, i32 r, 
    i32 s, i32 t, i32 u,
    i32 v, i32 w, i32 x,
    i32 y, i32 z) -> i32
{
    ret a * b * c * d * e * f * g * h * i * j * k * l * m * n * o * p * q * r * s * t * u * v * w * x * y * z;
}

hide fun function_overload(i32 a, i32 b) -> i32
{
    ret a + b;
}
hide fun function_overload(f64 a, f64 b) -> f64
{
    ret a + b;
}
hide fun function_overload(i32 count, ...) -> TC.SmallTest
{
    va_list list = va_start();
    TC.SmallTest result = {};
    for (i32 i = 0; i < count; i = i + 1)
    {
        TC.SmallTest st = va_arg(list, TC.SmallTest);
        result.testVar = result.testVar + st.testVar;
        result.smallValue = result.smallValue + st.smallValue;
    }
    va_end(list);
    ret result;   
}

expose fun use_constant(i32 val) -> i32
{
    constant i32 addend = 100;
    ret val + addend;
}

expose fun constant_ptr(u8* data) -> void
{
    *data = 42; // should be allowed
    ret;
}

expose fun constant_test(i32 val) -> void
{
    val = 20; // should cause no effect to caller
    ret;
}

expose fun internal_diffvarargs(i32 empty, ...) -> void
{
    va_list list = va_start();
    i32 first = va_arg(list, i32);
    f64 second = va_arg(list, f64);
    string third = va_arg(list, string);
    Std.IO.print("internal_diffvarargs: first=%d, second=%lf, third=%s\n", first, second, third);
    va_end(list);
    ret;
}

expose fun structvarargs(i32 count, ...) -> i32
{
    va_list list = va_start();
    i32 total = 0;
    for (i32 i = 0; i < count; i = i + 1)
    {
        TC.SmallTest st = va_arg(list, TC.SmallTest);
        total = total + (st.testVar as i32);
    }
    va_end(list);
    ret total;
}

hide fun max<T0: integral>(T0 a, T0 b) -> T0
{ 
    if (a > b)
        ret a;
    ret b;
}

expose fun default_max<T0: i32>(T0 a, T0 b) -> T0
{
    ret max(a, b);
}

hide fun other<T0: integral, T1: integral>(T0 a, T1 b) -> i32
{
    ret (a as i32) + (b as i32);
}

hide fun dot_sum<TLeft: integral, TRight: integral, TAccum: i64>(TLeft* left, TRight* right, i32 count) -> TAccum
{
    TAccum total = 0;
    for (i32 i = 0; i < count; i = i + 1)
    {
        total = total + ((left[i] as TAccum) * (right[i] as TAccum));
    }
    ret total;
}

hide fun funptr_test(i32 a, i32 b) -> i32
{
    ret a + b;
}

hide fun passbystruct(TC.SmallTest st) -> i32
{
    ret st.testVar as i32;
}

hide fun returnbystruct(TC.SmallTest st) -> TC.SmallTest
{
    ret st;
}

hide fun construct_thing() -> TC.SmallTest
{
    TC.SmallTest thing = {};
    thing.smallValue = 5;
    thing.testVar = 10;
    ret thing;
}

hide fun strlen(string strg) -> i32
{
    i32 len = 0;
    while (strg[len])
    {
        len++;
    }
    ret len;
}

hide fun strcmp(string a, string b) -> i32
{
    i32 i = 0;
    while (a[i] && b[i])
    {
        if (a[i] != b[i])
        {
            ret (a[i] - b[i]) as i32;
        }
        i++;
    }
    ret (a[i] - b[i]) as i32;
}

hide fun abort() -> void
{
    exit(1);
    ret;
}

expose fun test_overflow() -> i16
{
    i16 x = 30000;
    i16 y = 10000;
    ret x + y; // expect overflow to -25536
}

hide fun test_mul_overflow() -> u8
{
    u8 a = 200;
    u8 b = 200;
    ret a * b; // expect overflow to 64 (200*200=40000 -> 40000 % 256 = 64)
}

[OverrideMetadata(".func differentsig ret=void params=0 locals=0")]
hide fun test_idk() -> void
{
    Std.IO.print("Hello from sigfunction!\n");
    ret;
}

[ChanceCode]
fun rawthing(i32 a) -> i32
{
    const i32 456;
    load_param 0;
    binop add i32;
    ret;
}