module Test.Program;

bring Test.Chance as TC;
bring LibTest as LT;
bring LibTest.Another;

bring Std as Std;

extend from "C" i32 printf(char *, _vaargs_);
extend from "C" i32 write(int, char *, int);
extend from "C" i32 read(i32, char *, int);
extend from "C" void *malloc(int);
extend from "C" void free(void *);
extend from "C" void exit(int);
extend from "C" int test();

extend fun test_chance() -> i32;

hide alias string = char*;
hide alias ptr<T> = T*;

hide fun printwrapper() -> i32
{
    ret printf("Hello, %s! Number: %d\n", "CHance", 42);
}

expose enum Element
{
    ElementPart, // Auto 0
    ElementPart2, // Auto 1
    SetElement = 3 // 3
};

expose struct AnElement
{
    Element internalElement;
    Element* ptrToElement;
};

expose struct OtherElement
{
    i32 part;
    char* str;
    u64 bignumber;
    AnElement thisthing; // Will error because AnElement is hidden and cannot be used in an exposed struct
    AnElement* ptrToSmth;
};



[EntryPoint]
expose fun main() -> i32
{
    // allocate 128 bytes for input
    ptr<void> buf = Std.Memory.Allocate(128);

    // prompt the user
    write(1, "What's your name? > ", 20);

    // read from stdin (fd = 0), max 127 chars
    i32 len = read(0, buf as char *, 127);

    // test printwrapper result
    i32 printed = printwrapper();
    printf("Read %d bytes (printwrapper printed %d chars)\n", len, printed);

    // null-terminate the string safely
    string str = buf as string;
    if (len > 0)
    {
        if (str[len - 1] == '\n') str[--len] = 0;
        if (len > 0 && str[len - 1] == '\r') str[--len] = 0;
    }
    else
    {
        printf("No input read, using empty string\n");
        str[0] = 0;
    }

    // print greeting
    printf("Hello, %s!\n", str);

    printf("String length: %d\n", strlen(str));

    string cmp_target = "CHance";

    if (strcmp(str, cmp_target) == 0)
    {
        printf("You entered the secret name!\n");
    }
    else
    {
        printf("You did not enter the secret name.\n");
    }

    printf("Freeing memory...\n");
    Std.Memory.Deallocate(buf as void*);

    // Test overflow behavior
    i16 of = test_overflow();
    printf("Overflow test result (should be -25536): %d\n", of);

    printf("Calling test_chance(): %d\n", TC.test_chance());

    printf("Calling extended C function test(): %d\n", test());

    printf("Multiplication test: 6 * 7 = %d\n", 6 * 7);

    printf("Multiplication overflow test (200 * 200 = 64): %d\n", test_mul_overflow());

    printf("Division test: 20 / -4 = %d\n", 20 / -4); // expect -5

    printf("Test hex output: %d in hex is %x\n", 0xFF, 0xFF);

    TC.SmallTest vari = {};
    vari.smallValue = 3;
    vari.testVar = 44;
    
    TC.SmallTest another = {
        .smallValue = 123,
        .testVar = 333 
    };

    TC.SmallTest* test = &vari;

    TC.SmallTest deref = *test;

    printf("Type of deref test: %d\n", deref.testVar); // expect 44

    i32 testint = 123;
    i32* testintp = &testint;
    i32** testintpp = &testintp;
    printf("Ptrptr deref: %d\n", testintpp[0][0]); // expect 123

    TC.SmallTest* addptr = Std.Memory.Allocate(sizeof(TC.SmallTest) * 2) as TC.SmallTest*;
    addptr[0] = construct_thing();
    addptr[1] = another;

    printf("addptr[0].smallValue = %d\n", (*addptr).smallValue); // expect 5
    printf("addptr[1].smallValue = %d\n", (*(addptr + 1 * 2 / 2)).smallValue); // expect 123, optimized constant folding

    Std.Memory.Deallocate(addptr as void*);

    i32* testintptr = test as i32*;
    printf("testVar via intptr: %p\n", testintptr);

    Element elem = Element.SetElement;

    test=>testVar = 45;

    if (test=>testVar == 45 || another.smallValue == 3)
    {
        printf("Logical OR worked!\n");
    }

    i32 a = 1 << 1;
    printf("1 << 1 = %d\n", a); // expect 2

    i32 b = 4 >> 1;
    printf("4 >> 1 = %d\n", b); // expect 2

    printf("typeof() = %s with sizeof() = %d\n", typeof(TC.SmallTest), sizeof(TC.SmallTest));

    [MetadataCall("differentsig")]();

    test_idk();

    printf("Raw thing: %d\n", rawthing(10)); // expect 466

    printf("Result from LibTest: %d\n", LT.test_fun(41));

    printf("Result from LibTest.Another: %d\n", LibTest.Another.other_test_fun(50)); // Will be 60

    printf("Exit code should be %d\n", ((vari.testVar as i32) + (another.smallValue as i32)));

    ret ((vari.testVar as i32) + (another.smallValue as i32)); // expect 45 + 123 = 168
}

hide fun construct_thing() -> TC.SmallTest
{
    TC.SmallTest thing = {};
    thing.smallValue = 5;
    thing.testVar = 10;
    ret thing;
}

hide fun strlen(string strg) -> i32
{
    i32 len = 0;
    while (strg[len])
    {
        len++;
    }
    ret len;
}

hide fun strcmp(string a, string b) -> i32
{
    i32 i = 0;
    while (a[i] && b[i])
    {
        if (a[i] != b[i])
        {
            ret a[i] - b[i];
        }
        i++;
    }
    ret a[i] - b[i];
}

hide fun abort() -> void
{
    exit(1);
    ret;
}

expose fun test_overflow() -> i16
{
    i16 x = 30000;
    i16 y = 10000;
    ret x + y; // expect overflow to -25536
}

hide fun test_mul_overflow() -> u8
{
    u8 a = 200;
    u8 b = 200;
    ret a * b; // expect overflow to 64 (200*200=40000 -> 40000 % 256 = 64)
}

[OverrideMetadata(".func differentsig ret=void params=0 locals=0")]
hide fun test_idk() -> void
{
    printf("Hello from sigfunction!\n");
    ret;
}

[ChanceCode]
fun rawthing(i32 a) -> i32
{
    const i32 456;
    load_param 0;
    binop add i32;
    ret;
}